#include <iostream>#include <string>#include <list>#include <vector>#include <cstdlib>#include <algorithm>#include <iterator>#include <deque>#include <set>#include <map>/*模板类 vector*/#if 0const int NUM = 5;int main(){	using namespace std;	/*	方便创建动态分配的数组	*/	vector<int> rating(NUM);	vector<string> titles(NUM);	cout << "输入: ";	for (int i = 0; i < NUM; i++)	{		cout << "输入string # " << i + 1 << ": ";		getline(cin, titles[i]);		cout << "输入int: ";		cin >> rating[i];		cin.get();	}	for (int i = 0; i < NUM; i++)	{		cout << titles[i] << ": " << rating[i] << endl;	}	return 0;}/*基本操作:	size()	swap()	begin()	end()迭代器: 广义指针每个容器类都定义了一个合适的迭代器 	vector： iterator	声明迭代器: vector<double>::iterator pd迭代显示数组内容: 	for (pd=scores.begin();pd!=scores.end();pd++)		cout<<*pd<<endl;begin()的随机访问操作 begin()+1: 第二个元素*//** 基本方法:			size()		begin()		end()		push_back()		erase()		insert()*/#elif 0/*一个展示一些操作的例子*/struct Review{	std::string title;	int rating;};bool FillReview(Review& rr);void ShowReview(const Review& rr);	int main(){	using std::cout;	using std::vector;	vector<Review> books;	Review temp;	while (FillReview(temp))	{		//添加到容器的末尾		books.push_back(temp);	}	int num = books.size();	if (num > 0)	{		cout << "这是你输入的信息: ";		for (int i = 0; i < num; i++)		{			ShowReview(books[i]);		}		//迭代器		vector<Review>::iterator pr;		for (pr = books.begin(); pr < books.end(); pr++)		{			ShowReview(*pr);		}		//复制books容器的值到oldlis容器中		vector<Review> oldlis(books);			if (num > 3)		{			//删除books 第2 3 个元素	左闭右开			books.erase(books.begin() + 1, books.begin() + 3);			std::cout << "After erase: " << std::endl;			/*			控制迭代器来进行循环			*/			for (pr = books.begin(); pr != books.end(); pr++)			{				ShowReview(*pr);			}			//第二个元素插入到books的前面  左闭右开			books.insert(books.begin(), oldlis.begin() + 1,				oldlis.begin() + 2);			std::cout << "After insert: " << std::endl;			/*			控制迭代器来进行循环			*/			for (pr = books.begin(); pr != books.end(); pr++)			{				ShowReview(*pr);			}		}		books.swap(oldlis);	// oldlis容器和books容器的元素互换		std::cout << "After swap: " << std::endl;		/*			控制迭代器来进行循环		*/		for (pr = books.begin(); pr != books.end(); pr++)		{			ShowReview(*pr);		}	}	else	{		cout << "Nothing\n";	}	return 0;}bool FillReview(Review& rr){	std::cout << "输入书籍的名称: <quit退出>";	std::getline(std::cin, rr.title);	if (rr.title == "quit")	{		return false;	}	std::cout << "输入书籍的分数: ";	std::cin >> rr.rating;	if (!std::cin)		return false;	while (std::cin.get() != '\n')		;	return true;}void ShowReview(const Review& rr){	std::cout << rr.rating << ": " << rr.title << std::endl;}#elif 0/*3个代表性的 STL 函数	for _each:		3个参数 : 2定义容器中区间的迭代器  函数指针		for_each 指向的函数应用于容器区间的各个元素		使用 for_each 替代for循环	random_shuffle :		接受两个指定区间的迭代器  并且随机排序区间元素	sort*/using namespace std;struct Review{	std::string title;	int rating;};bool operator<(const Review& r1, const Review& r2);bool worseThan(const Review& r1, const Review& r2);bool FillReview(Review& rr);void ShowReview(const Review& rr);int main(){	vector<Review> books;	Review temp;	while (FillReview(temp))	{		books.push_back(temp);	}	if (books.size() > 0)	{		cout << "你是输入了" << books.size() << "本书籍，这是你的输入信息:\n";		// algorithm 头文件		/*		替代for循环的方法  区间+显示函数		*/		//for_each(books.begin(), books.end(), ShowReview);		/*		基于范围的for循环		*/		for (auto x : books)		{			ShowReview(x);		}		/*		排序:  区间		重载 < 运算符		*/		sort(books.begin(), books.end());		cout << "排序: 名称 评分: " << endl;		for_each(books.begin(), books.end(), ShowReview);		/*		排序: 区间		自定义排序方式		*/		sort(books.begin(), books.end(), worseThan);		cout << "排序: 名称 评分: " << endl;		for_each(books.begin(), books.end(), ShowReview);		/*		随机排序区间内的元素		*/		random_shuffle(books.begin(), books.end());		cout << "After shuffle: 名称 评分" << endl;		for_each(books.begin(), books.end(), ShowReview);	}	else	{		cout << "废物" << endl;	}	return 0;}bool operator<(const Review& r1, const Review& r2){	if (r1.title < r2.title)		return true;	else if (r1.title == r2.title && r1.rating < r2.rating)		return true;	else		return false;}bool worseThan(const Review& r1, const Review& r2){	if (r1.rating < r2.rating)		return true;	else		return false;}bool FillReview(Review& rr){	std::cout << "输入书籍的名称: <quit退出>";	std::getline(std::cin, rr.title);	if (rr.title == "quit")	{		return false;	}	std::cout << "输入书籍的分数: ";	std::cin >> rr.rating;	if (!std::cin)		return false;	while (std::cin.get() != '\n')		;	return true;}void ShowReview(const Review& rr){	std::cout << rr.rating << ": " << rr.title << std::endl;}#elif 0/*基于范围的for循环*/int main(){	double x[5] = { 1,9,5,6,3 };	for (double a : x)	// auto  自动推断	{		std::cout << a << " ";	}	//可以修改容器的内容 	return 0;}#elif 0/*s泛型编程:	使用同一个函数来处理不同的容器类型的元素实现find函数  迭代器应该具有的特征:	1. 对迭代器执行解除引用的操作  *p	2. 能够将一个迭代器赋给另一个 p=q	3. 能够进行迭代器的比较  q==p q!=p	4. 使用迭代器遍历容器的所有元素  ++p p++迭代器: begin()  end()为使得算法能够满足其他的情况，应该定义能够满足算法需求的迭代器，并且加到容器设计上*//*-------迭代器类型----------1. 输入迭代器: -->> 单向迭代器 只读	读取容器中的信息	*p 读取容器中的值 const  	++p p++ 来访问容器中的值2. 输出迭代器: -->> 单项迭代器 只写	将信息从程序传输给容器	*p 修改容器的值3. 正向迭代器: -->> 可读可写	多次通行4. 双向迭代器:	双向遍历容器 例如最后一个与第一个元素互换5. 随机访问迭代器:	直接跳到容器的任何一个元素 随机访问功能: 	输入 = 输出 < 正向 < 双向 < 随机访问*//*概念 改进 模型*///指针用作迭代器int main(){	/*	----有用的迭代器 : ostream_iterator  istream_iterator	*/	std::vector<double>::iterator a;	std::list<int>::iterator b;	int cast[10] = { 1,2,3,4,5,6,7,8,9,0 };	std::vector<int> dice[10];	//将一个数组复制到另一个矢量中	//前两个表示要复制的范围 最后一个时目标数组  	//将覆盖已有的数据	copy(cast, cast + 10, dice->begin());		/*	-------输出迭代器---------	能够使用cout来显示信息   一个适配器	int : 发送给输出流的数据类型 	char: 输出流使用的数据类型	" " : 发送给输出流后每个数据项后显示的分隔符	*/	std::ostream_iterator<int, char>out_iter(std::cout, " ");//构造函数	*out_iter++ = 15;		//将 15和空格组成的字符串发送到cout管理的输出流中  并为下一个输出流做准备	//将dice整个区间复制到输出流中 显示容器的内容	copy(dice->begin(), dice->end(), out_iter);	//创建匿名迭代器:	copy(dice->begin(), dice->end(), std::ostream_iterator<int, char>(std::cout, " "));	//------输入迭代器--------	copy(std::istream_iterator<int, char>(std::cin), std::istream_iterator<int, char>(),		dice->begin());	/*	----预定义迭代器类型-----	reverse_iterator :		rbegin() 指向超尾的反向迭代器		rend()   指向第一个元素的反向迭代器	back_insert_iterator：  快速插入		将元素插入到容器尾部  	front_insert_iterator： 速度快		将元素插入到容器前端	insert_iterator：		将元素插入到insert_iterator构造函数的参数指定位置的前面	*/	return 0;}#elif 0/*迭代器例子*/#if 0int main(){	using namespace std;	int cast[10] = { 1,2,3,4,5,6,7,8,9,0 };	vector<int>dice(10);	//数组复制到容器	copy(cast, cast + 10, dice.begin());	cout << "显示容器内容: " << endl;	/*	创建一个输出流迭代器	*/	ostream_iterator<int, char>out_iter(cout, " ");	copy(dice.begin(), dice.end(), out_iter);	cout << endl;	copy(dice.begin(), dice.end(), ostream_iterator<int, char>(cout, " "));	cout << endl;	/*	*****  使用STL函数   ***** 这个好	*/	cout << "隐式反向容器: " << endl;;	copy(dice.rbegin(), dice.rend(), out_iter);	cout << endl;	/*	显式声明迭代器	*/	cout << "显式反向容器: " << endl;	vector<int>::reverse_iterator ri;	for (ri = dice.rbegin(); ri != dice.rend(); ++ri)	{		cout << *ri << " ";	}	cout << endl;	return 0;}#elif 1void output(const std::string& s){	std::cout << s << " ";}int main(){	using namespace std;	string s1[4] = { "第一名","第二名","第三名","第四名" };	string s2[2] = { "我很忙","我很帅" };	string s3[2] = { "我很傻","我很牛" };	vector<string> words(4);	//复制到容器	copy(s1, s1 + 4, words.begin());	for_each(words.begin(), words.end(), output);	cout << endl;	/*	back_insert_iterator  容器尾部插入	同时可以自动增长容器的长度	*/	copy(s2, s2 + 2, back_insert_iterator<vector<string>>(words));	for_each(words.begin(), words.end(), output);	cout << endl;	/*	insert_iterator			在某个位置插入	同时可以自动增长容器的长度	*/	copy(s3, s3 + 2, insert_iterator<vector<string>>(words, words.begin()));	//容器的begin处插入	for_each(words.begin(), words.end(), output);	cout << endl;	return 0;}#endif/*容器种类 :	1. 容器概念		复杂度:  从快到慢			编译时间   固定时间   线性时间	2. 容器类型*//*七种序列的容器类型 :	共同支持的运算符: 	insert erase clear	1. vector ：front	 back	 push_back	pop_back		自动内存管理的数组		尾部添加和删除是 固定时间; 头部添加和删除是 线性时间		可反转容器 rbegin rend -> 指向反转后的第一个元素的迭代器和指向反转后的超尾的迭代器		强调通过随机访问进行快速的访问		reverse_iterator 	2. deque ： 基本支持所有 但是vector更快		双端队列  		头部位置插入和删除元素是固定时间; 如果多数操作发生在序列头部要使用deque数据结构	3. list  ：		双向链表 		在任意位置插入删除元素都是固定时间 		具有链表专用的成员函数: merge remove sort splice unique		强调元素的快速插入和删除		1). list工具箱		2). forward_list(C++11) 实现单链表 正向迭代器 不可反转容器 简单紧凑功能少	4. queue ：		队列		适配器类 : ostream_iterator   istream_iterator		操作 : empty() size() front() back() push() pop()	5. priority_queue ：		适配器类 		与queue的不同之处 : 将最大的元素移动到队首 可以修改将哪个元素放在队首的比较方式	6. stack ：		栈		操作 : empty() size() top() push() pop()	7. array (C++11) ：		长度固定 没有调整容器大小的操作 		但是具有一些对他来说有意义的成员函数：operator[] 和 at()  		可以将STL算法用于array对象: copy() for_each()*/#elif 0/*list 链表的操作*/void output(const int& s){	std::cout << s << " ";}int main(){	using namespace std;	list<int> one(5, 2);		//数量:  5  元素: 2	int stuff[5] = { 1,2,3,4,5 };	list<int> two;	/*	insert: 在链表的前端插入区间元素	*/	two.insert(two.begin(), stuff, stuff + 5);	int more[6] = { 1,2,3,4,5,6 };	list<int> three(two);	/*	insert ： 在链表的末尾插入区间元素   区间副本	*/	three.insert(three.end(), more, more + 6);	cout << "List  one: " << endl;	for_each(one.begin(), one.end(), output);	cout << "\nList  two: " << endl;	for_each(two.begin(), two.end(), output);	cout << "\nList  three: " << endl;	for_each(three.begin(), three.end(), output);	/*	remove ： 删除链表所有val元素	*/	three.remove(2);	cout << "\nList  remove <2> three: " << endl;	for_each(three.begin(), three.end(), output);	/*	splice ： 将链表one的元素插入到pos位置的前面  固定时间	区间本身	*/	three.splice(three.begin(), one);	cout << "\nList  splice <one> three: " << endl;	//----注意 使用splice后 被插入的链表变为空  one 	/*for (auto x : one)	{		cout << x << " ";	}*/	for_each(three.begin(), three.end(), output);	/*	unique ： 删除链表的连续的重复元素 -->> 111232 -> 1232	*/	three.unique();	cout << "\nList unique three: " << endl;	for_each(three.begin(), three.end(), output);	/*	sort   :  链表元素从小到大排序	*/	three.sort();	//排序	three.unique();	//删除连续重复	cout << "\nList sort three: " << endl;	for_each(three.begin(), three.end(), output);	/*	merge  ： 将两个已经排序好的链表合并 (必须是排序好的 否则报错)	*/	//two.sort();	three.merge(two);	cout << "\nList three merge <two> three: " << endl;	//基于范围的for循环	for (auto x : three)	{		cout << x << " ";	}	return 0;}/*-----------关联容器------------ X::key_type优点 ： 提供对元素的快速访问	1. set 		关联集合  可反转  可排序  键唯一  不能存储多个相同的值		set<string,less<string>> A  存储的值类型:string  显式指定模板参数  第二个参数可选	2. multiset			3. map	4. multimap	可以反转  经过排序  一个键可能与多个值相关联		multimap<int,string> codes ：键类型:int 存储的值类型: string 第三个参数可选*/#elif 0/*set  示例*/int main(){	using namespace std;	const int N = 6;	string r1[N] = { "我是一","我是二","我是三","我是四","我是五","我是六" };	string r2[N] = { "我是一","二","我是三","四","五","六" };	/*	set关联容器初始化并且赋值	*/	set<string> A(r1, r1 + N);	set<string> B(r2, r2 + N);	ostream_iterator<string, char> out(cout, " ");	cout << "Set A:\n";	copy(A.begin(), A.end(), out);	cout << endl;	cout << "Set B:\n";	copy(B.begin(), B.end(), out);	cout << endl;	/*	set_union ：两个容器合并 并且按字母从小到大排序	*/	cout << "Union of A and B:\n";	set_union(A.begin(), A.end(), B.begin(), B.end(), out);	cout << endl;	/*	set_intersection ：查找两个容器的交集	*/	cout << "Intersection of A and B:\n";	set_intersection(A.begin(), A.end(), B.begin(), B.end(), out);	cout << endl;	/*	set_difference ：获得两个集合的差	*/	cout << "Difference of A and B:\n";	set_difference(A.begin(), A.end(), B.begin(), B.end(), out);	cout << endl;	/*	将两个区间的集合元素 复制到C关联容器中	*/	set<string> C;	cout << "Set C:\n";	set_union(A.begin(), A.end(), B.begin(), B.end(),		insert_iterator<set<string>>(C, C.begin()));	copy(C.begin(), C.end(), out);	cout << endl;	/*	插入到C的头部	*/	string s3("grungy");	C.insert(s3);	cout << "Set C after insertion:\n";	copy(C.begin(), C.end(), out);	cout << endl;	cout << "Showing a range:\n";	copy(C.lower_bound("ghost"), C.upper_bound("spook"), out);	cout << endl;	return 0;}#elif 0/*multimap 关联容器*/typedef int Keytype;typedef std::pair<Keytype, std::string> Pair;typedef std::multimap<Keytype, std::string> MapCode;int main(){	using namespace std;	MapCode codes;	/*	创建匿名pair对象 并插入到multimap容器	*/	/*	对于pair对象，使用first和second成员来访问两个部分	*/	codes.insert(Pair(415, "San Francisco"));	codes.insert(Pair(510, "Oakland"));	codes.insert(Pair(718, "Brooklyn"));	codes.insert(Pair(718, "Staten Island"));	codes.insert(Pair(415, "San Rafael"));	codes.insert(Pair(510, "Berkeley"));	cout << "415的 城市: " << codes.count(415) << endl;	cout << "718的 城市: " << codes.count(718) << endl;	cout << "510的 城市: " << codes.count(510) << endl;	cout << "城市面积:\t城市:\n";	MapCode::iterator it;		/*	first和second返回两个键值	*/	for (it = codes.begin(); it != codes.end(); ++it)	{		cout << "	 " << (*it).first << "	 " << (*it).second << endl;	}	/*	equal_range 键作为参数 返回两个迭代器	*/	pair<MapCode::iterator, MapCode::iterator> range =		codes.equal_range(718);	cout << "718的城市:\n";	for (it = range.first; it != range.second; ++it)	{		cout << (*it).second << endl;	}	return 0;}#endif